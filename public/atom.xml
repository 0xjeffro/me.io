<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jᥱffr᧐.𝓲𝓸</title>
  
  <subtitle>Never waste a crisis. | All in web3.</subtitle>
  <link href="http://jeffro.io/atom.xml" rel="self"/>
  
  <link href="http://jeffro.io/"/>
  <updated>2023-05-25T03:29:41.396Z</updated>
  <id>http://jeffro.io/</id>
  
  <author>
    <name>Jᥱffr᧐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://jeffro.io/posts/hello-world-new/"/>
    <id>http://jeffro.io/posts/hello-world-new/</id>
    <published>2023-05-24T15:01:48.943Z</published>
    <updated>2023-05-25T03:29:41.396Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>wow👍🏻<br>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>图解马拉车算法及其Golang实现</title>
    <link href="http://jeffro.io/posts/illustratbe-manacher-algorithm-zh/"/>
    <id>http://jeffro.io/posts/illustratbe-manacher-algorithm-zh/</id>
    <published>2023-02-01T10:30:45.000Z</published>
    <updated>2023-02-02T14:00:57.013Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现网上普遍对马拉车算法（Manacher’s Algorithm）的讲解有些拘泥于算法细节。这片文章只介绍原理，实现的细节可直接参考最后的代码实现。</p><span id="more"></span><h2 id="什么是马拉车算法"><a href="#什么是马拉车算法" class="headerlink" title="什么是马拉车算法"></a>什么是马拉车算法</h2><p>马拉车算法能以 $O(n)$ 的时间复杂度求得字符串$s$的最长子回文。</p><p>如果读不懂上面👆🏻这句话，可以参考这道题目👉🏻 <a href="https://leetcode.cn/problems/longest-palindromic-substring/">Leetcode 5. 最长回文子串</a>。</p><p>最长回文子串问题有一个朴素的 $O(n^2)$ 的算法很容易想到，就是枚举对称中心，以对称中心为起点向$s$两侧扩散，这叫做中心扩散法。</p><p>实际上，<strong>马拉车算法就中心扩散法的优化</strong>。</p><h2 id="怎么优化"><a href="#怎么优化" class="headerlink" title="怎么优化"></a>怎么优化</h2><p>假设 $s=cbcbccde$, 我们开一个数组 $p$ ， $p[i]$ 表示以 $s[i]$ 为对称中心的那个最长的回文子串的半径长度。这样说可能比较拗口，举个例子就明白了，如图1。</p><div class="tag-plugin image"><div class="image-bg" style="background:white;padding:20px;"><img src="1.png" alt="图1. 例，因为以s[2]为中心的最长回文是cbcbc，半径为3，故p[2]=3 。" fancybox="true" style="width:400px;"/><a class="image-download blur" style="opacity:0" href="1.png"><svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3734"><path d="M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z" p-id="3735"></path></svg></a></div><div class="image-meta"><span class="image-caption center">图1. 例，因为以s[2]为中心的最长回文是cbcbc，半径为3，故p[2]=3 。</span></div></div><p> $p$ 数组的值是很容易利用中心扩散法求解出来的，只是这样做时间复杂度是$O(n^2)$的。马拉车算法就是利用 $p$ 中已知的信息将算法优化到了$O(n)$。下面举个例子，假设目前 $p[0], p[1], p[2]$ 已知，现在我们要求出$p[3]$ ，如图2所示。</p><div class="tag-plugin image"><div class="image-bg" style="background:white;padding:20px;"><img src="2.png" alt="图2. p[0~2]已知，欲利用已知信息求得p[3] 。" fancybox="true" style="width:400px;"/><a class="image-download blur" style="opacity:0" href="2.png"><svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3734"><path d="M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z" p-id="3735"></path></svg></a></div><div class="image-meta"><span class="image-caption center">图2. p[0~2]已知，欲利用已知信息求得p[3] 。</span></div></div><p>下面阐述一个事实：已知的右界最靠右的最长子回文的对称中心是$s[2]$, 其右界是$s[4]$。这个事实看图很好理解，如图3所示。</p><div class="tag-plugin image"><div class="image-bg" style="background:white;padding:20px;"><img src="3.png" alt="图3. 红线是对称轴，s[4]是当前已知的最右右界 。" fancybox="true" style="width:400px;"/><a class="image-download blur" style="opacity:0" href="3.png"><svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3734"><path d="M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z" p-id="3735"></path></svg></a></div><div class="image-meta"><span class="image-caption center">图3. 红线是对称轴，s[4]是当前已知的最右右界 。</span></div></div><p>承认了上面的事实就好办了，此时，我们要求的p[3]位于下标3，处于中心2和右界4的区间内。根据对称性，$p[3]\ge p[2-(3-2)] = 2$ 马拉车算法的精髓就在这一步。 其中 $p[3]\ge p[2-(3-2)]$ 就是 $p[1]$ , 是 $p[3]$ 关于图3中红色对称轴的对称点。</p><h2 id="一些特殊情况"><a href="#一些特殊情况" class="headerlink" title="一些特殊情况"></a>一些特殊情况</h2><p>上面为什么说$p[3] \ge p[1]$ ，而不是$p[3] = p[1]$呢，我们看下面图4中的例子，对于这个例子，很显然$p[3]$的真实值是3，比$p[1]$的要大。</p><p>这个原因很简单，就是因为我们已知的信息是有限的，即使我们利用了已知的最右的右界，真实的情况却是$p[3]$的右界还是超出了最右右界的范围。</p><p>为了处理这种情况，我们通过马拉车算法算出一个$p[i]$后（ 此时这个$p[i]$可能小于真实值），只需以$s[i]$为对称中心，以半径$p[i]$为起始值执行中心扩散，并不断更新$p[i]$。在图4的例子中，$i=3$。</p><div class="tag-plugin image"><div class="image-bg" style="background:white;padding:20px;"><img src="4.png" alt="图4. 注意这里为了说明问题，对样例稍加改动，s[5]=b 。" fancybox="true" style="width:400px;"/><a class="image-download blur" style="opacity:0" href="4.png"><svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3734"><path d="M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z" p-id="3735"></path></svg></a></div><div class="image-meta"><span class="image-caption center">图4. 注意这里为了说明问题，对样例稍加改动，s[5]=b 。</span></div></div><p>还有一种特殊情况，就是利用已知信息计算 $p[i]$ 只有在 $i$ 处于图3中的红色对称轴和对应的右界之间的时候才可行，其它情况直接采用中心扩散法计算 $p[i]$ 即可。</p><h2 id="关于偶回文"><a href="#关于偶回文" class="headerlink" title="关于偶回文"></a>关于偶回文</h2><p>上面的例子我们为了直达核心，都只考虑了奇回文（回文长度为奇数），忽略了偶回文的求解。偶回文的麻烦之处在于它的对称轴在两个字符之间。我们可以通过一个简单的小trick来把偶回文的问题转化为奇回文。就是把字符串$s$中的字符用一个符号隔开，比如 $abac$ 变成 <script type="math/tex">\# a \# b \# a \# c \#</script> 。这样操作后，偶回文就转化成了奇回文，奇回文仍是奇回文。</p><h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><p>下面是 <a href="https://leetcode.cn/problems/longest-palindromic-substring/">Leetcode 5. 最长回文子串</a> 的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">ss := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(s)*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">ss[<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span></span><br><span class="line">si := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">ss[si] = s[i]</span><br><span class="line">si++</span><br><span class="line">ss[si] = <span class="string">&#x27;#&#x27;</span></span><br><span class="line">si++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Manacher&#x27;s algorithm</span></span><br><span class="line">p := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(ss))</span><br><span class="line">mid, maxRight := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">maxPos := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ss); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; maxRight &#123;</span><br><span class="line">p[i] = Min(p[<span class="number">2</span>*mid-i], maxRight-i)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p[i] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i+p[i] &lt; <span class="built_in">len</span>(ss) &amp;&amp; i-p[i] &gt; <span class="number">-1</span> &amp;&amp; ss[i+p[i]] == ss[i-p[i]] &#123;</span><br><span class="line">p[i]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i+p[i] &gt; maxRight &#123;</span><br><span class="line">mid = i</span><br><span class="line">maxRight = i + p[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> p[i] &gt; p[maxPos] &#123;</span><br><span class="line">maxPos = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s[(maxPos-p[maxPos]+<span class="number">1</span>)/<span class="number">2</span> : (maxPos+p[maxPos]<span class="number">-1</span>)/<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测评结果：</p><div class="tag-plugin image"><div class="image-bg" style="background:white;padding:20px;"><img src="5.png" fancybox="true" style="width:400px;"/><a class="image-download blur" style="opacity:0" href="5.png"><svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3734"><path d="M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z" p-id="3735"></path></svg></a></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近发现网上普遍对马拉车算法（Manacher’s Algorithm）的讲解有些拘泥于算法细节。这片文章只介绍原理，实现的细节可直接参考最后的代码实现。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
